import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let currentPolytopeMesh = null; // Mesh for faces using multi-material groups
let currentEdgesMesh = null;    // LineSegments mesh for edges
let faceMaterials = [];         // Array of MeshStandardMaterial for faces
let edgeMaterial;               // Single LineBasicMaterial for edges
let isViewerReady = false;      // Flag to check if mesh exists and is ready for updates

// --- Initialization ---
export function init(canvas) {
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee); // Light gray background

    // Camera
    const aspectRatio = canvas.clientWidth > 0 ? canvas.clientWidth / canvas.clientHeight : 1;
    camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
    camera.position.z = 3; // Pull camera back

    // Renderer
    renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        preserveDrawingBuffer: true // Needed for stable exportToPNG
    });
    renderer.setSize(canvas.clientWidth || window.innerWidth, canvas.clientHeight || window.innerHeight); // Initial size fallback
    renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI displays

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1).normalize();
    scene.add(directionalLight);

    // Controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Smooths camera movement
    controls.dampingFactor = 0.1;
    controls.rotateSpeed = 0.5;

    // Edge Material (create once)
    edgeMaterial = new THREE.LineBasicMaterial({
        color: 0x1a1a1a, // Dark gray / near black
        linewidth: 1,    // Note: linewidth > 1 not guaranteed cross-platform
    });

    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    // Ensure initial size is correct after layout stabilizes
    setTimeout(onWindowResize, 100); // Small delay to help layout settle

    // Start the animation loop
    animate();
}

// Helper to check if a mesh is loaded and ready for style updates
export function isReady() {
    return isViewerReady && currentPolytopeMesh !== null && faceMaterials.length > 0;
}


// --- Core Update Function ---
/** Creates/updates the face and edge meshes for the given polytope data. */
export function updatePolytopeMesh(polytopeData) {
    isViewerReady = false; // Mark as not ready while updating

    // --- Cleanup previous meshes and materials ---
    if (currentPolytopeMesh) {
        scene.remove(currentPolytopeMesh);
        currentPolytopeMesh.geometry.dispose();
        // Dispose individual materials in the array
        faceMaterials.forEach(mat => mat.dispose());
        faceMaterials = []; // Clear the array
        currentPolytopeMesh = null;
    }
    if (currentEdgesMesh) {
        scene.remove(currentEdgesMesh);
        currentEdgesMesh.geometry.dispose();
        // edgeMaterial is reused, no need to dispose here
        currentEdgesMesh = null;
    }

    // Exit if no valid data provided
    if (!polytopeData || !polytopeData.vertices || !polytopeData.faces) {
        console.error("Invalid polytope data provided to updatePolytopeMesh.");
        // Render the potentially empty scene
        if (renderer && scene && camera) renderer.render(scene, camera);
        return;
    }

    // --- Create Face Geometry and Materials ---
    const faceGeometry = new THREE.BufferGeometry();
    // Flatten vertices array: [[x,y,z],...] -> [x,y,z,x,y,z,...]
    const vertexPositions = polytopeData.vertices.flat();
    faceGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertexPositions, 3));

    const faceIndices = [];         // Holds vertex indices for all triangles
    let currentMaterialIndex = 0;   // Tracks which material/face we are on
    let vertexIndexOffset = 0;      // Tracks start index for the current group
    // Try to preserve opacity from previous state if possible
    const defaultOpacity = faceMaterials.length > 0 ? faceMaterials[0].opacity : 0.9;

    // Clear previous geometry groups and materials array
    faceMaterials = [];
    faceGeometry.clearGroups();

    polytopeData.faces.forEach((singleFaceVertexIndices, faceIndex) => {
        if (singleFaceVertexIndices.length < 3) {
            console.warn(`Skipping face ${faceIndex}: needs at least 3 vertices.`);
            return; // Skip invalid faces (less than 3 vertices)
        }

        // Create a new material instance for *each* face to allow individual colors
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff, // Default to white, color applied later by scheme
            metalness: 0.1,
            roughness: 0.75,
            side: THREE.DoubleSide, // Render both sides
            transparent: true,      // Enable opacity changes
            opacity: defaultOpacity,// Apply current/default opacity
        });
        faceMaterials.push(material);

        // Simple Fan Triangulation (assumes convex faces)
        // Creates triangles: (v0, v1, v2), (v0, v2, v3), ...
        const v0 = singleFaceVertexIndices[0];
        let trianglesAddedCount = 0;
        for (let i = 1; i < singleFaceVertexIndices.length - 1; i++) {
            const v1 = singleFaceVertexIndices[i];
            const v2 = singleFaceVertexIndices[i + 1];
            faceIndices.push(v0, v1, v2); // Add indices for one triangle
            trianglesAddedCount++;
        }

        // Add a geometry group: range of indices using the current material index
        const vertexCountForGroup = trianglesAddedCount * 3; // 3 vertices per triangle
        // .addGroup(start Index, count Indices, materialIndex)
        faceGeometry.addGroup(vertexIndexOffset, vertexCountForGroup, faceIndex);
        vertexIndexOffset += vertexCountForGroup; // Move offset for the next group

        currentMaterialIndex++; // Increment for the next face/material
    });

    // Apply the combined indices to the geometry
    faceGeometry.setIndex(faceIndices);
    // Calculate normals for correct lighting
    faceGeometry.computeVertexNormals();
    // Create the mesh using the geometry and the array of materials
    currentPolytopeMesh = new THREE.Mesh(faceGeometry, faceMaterials);
    scene.add(currentPolytopeMesh);

    // --- Create Edge Geometry ---
    const edgeGeometry = new THREE.BufferGeometry();
    const edgeIndices = [];            // Holds pairs of vertex indices for lines
    const uniqueEdges = new Set();     // To avoid drawing the same edge twice

    polytopeData.faces.forEach(singleFaceVertexIndices => {
        for (let i = 0; i < singleFaceVertexIndices.length; i++) {
            const idx1 = singleFaceVertexIndices[i];
            const idx2 = singleFaceVertexIndices[(i + 1) % singleFaceVertexIndices.length]; // Wrap around
            // Create a unique key for the edge regardless of vertex order (e.g., "1_5" vs "5_1")
            const edgeKey = Math.min(idx1, idx2) + '_' + Math.max(idx1, idx2);
            if (!uniqueEdges.has(edgeKey)) {
                edgeIndices.push(idx1, idx2); // Add the pair of indices
                uniqueEdges.add(edgeKey);      // Mark edge as added
            }
        }
    });

    // Edges use the same vertex positions as the faces
    edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertexPositions, 3));
    // Set the indices for the line segments
    edgeGeometry.setIndex(edgeIndices);
    // Create the line segments mesh using the edge geometry and shared edge material
    currentEdgesMesh = new THREE.LineSegments(edgeGeometry, edgeMaterial);
    scene.add(currentEdgesMesh);

    // --- Finalize Scene Setup for New Polytope ---
    // Reset camera controls to focus on the new object
    controls.reset();
    controls.target.set(0, 0, 0); // Ensure controls target the origin (if mesh isn't centered)

    // Basic auto-camera distance (optional refinement)
    try {
        faceGeometry.computeBoundingSphere();
        const radius = faceGeometry.boundingSphere.radius;
        if (radius > 0 && isFinite(radius)) {
            camera.position.z = Math.max(radius * 2.5, 2.0); // Don't get too close
        } else {
             camera.position.set(0, 0, 3); // Fallback position
        }
         camera.lookAt(0, 0, 0);
         controls.update(); // Apply changes
    } catch(e){
         console.error("Error computing bounding sphere:", e);
         camera.position.set(0, 0, 3); // Fallback position on error
    }


    isViewerReady = true; // Mark viewer as ready AFTER setup is complete
    console.log("Polytope mesh and edges updated in scene.");
}


// --- Style Updates ---

/**
 * Applies a color scheme array or a single color to the face materials.
 * @param {string[] | null} schemeColors - Array of hex color strings for the scheme. If null, uses singleHexColor.
 * @param {string} [singleHexColor] - A single hex color string used if schemeColors is null.
 */
export function applyColorScheme(schemeColors, singleHexColor) {
    if (!isReady()) { // Use the helper function
        console.warn("Cannot apply color scheme: Viewer not ready or no materials found.");
        return;
    }

    if (schemeColors && schemeColors.length > 0) {
        // Apply array of colors from the scheme
        faceMaterials.forEach((material, index) => {
            // Cycle through the scheme colors if there are more faces than colors
            const color = schemeColors[index % schemeColors.length];
            material.color.set(color);
        });
        console.log("Applied color scheme.");
    } else if (singleHexColor) {
        // Apply a single color to all face materials
        faceMaterials.forEach(material => {
            material.color.set(singleHexColor);
        });
        console.log(`Applied single color: ${singleHexColor}`);
    } else {
         console.warn("applyColorScheme called with invalid parameters (no scheme or single color).");
    }
}

/** Updates the opacity of ALL polytope face materials. Edges are not affected. */
export function updateFaceOpacity(opacityValue) {
    if (!isReady()) {
        // console.warn("Cannot update opacity: Viewer not ready."); // Can be noisy
        return;
    }

    // Clamp opacity value between 0 and 1
    const clampedOpacity = Math.max(0, Math.min(1, opacityValue));
    faceMaterials.forEach(material => {
        material.opacity = clampedOpacity;
        // Ensure transparency is enabled if opacity < 1. It's set to true on creation.
        // material.transparent = clampedOpacity < 1; // Generally okay to leave true
    });
    // console.log(`Updated face opacity to: ${clampedOpacity}`); // Optional log
}


// --- Export ---

/** Exports the current canvas view as a PNG image. */
export function exportToPNG() {
    try {
        // Ensure scene is rendered with latest changes BEFORE exporting
        // preserveDrawingBuffer:true in renderer init is important here
        renderer.render(scene, camera);

        const dataURL = renderer.domElement.toDataURL('image/png');

        // Create a temporary link element
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'polytope_export.png'; // Filename for the download

        // Programmatically click the link to trigger download
        document.body.appendChild(link); // Required for Firefox link click simulation
        link.click();
        document.body.removeChild(link); // Clean up the temporary link

        console.log("PNG Export triggered.");

    } catch (error) {
        console.error("Failed to export canvas to PNG:", error);
        // Optionally show an error message to the user via UI module
        alert("Error exporting image. See browser console for details.");
    }
}


// --- Internal Helpers ---

/** Handles window resize events to update camera aspect ratio and renderer size. */
function onWindowResize() {
    if (!renderer || !camera) return; // Exit if not initialized

    const canvas = renderer.domElement;
    const controlsElement = document.getElementById('controls');
    // Parent element should ideally be the main container (body or a div)
    const container = canvas.parentElement || document.body;

    const controlsWidth = controlsElement ? controlsElement.offsetWidth : 0;
    // Calculate available width and height for the canvas
    const width = container.clientWidth - controlsWidth;
    const height = container.clientHeight;

    // Only resize if dimensions are valid and changed
    if (width > 0 && height > 0) {
         // Check if size actually needs changing to avoid unnecessary work
        if (canvas.width !== width || canvas.height !== height) {
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            console.log(`Resized renderer to ${width}x${height}`);
        }
    } else {
        console.warn(`Skipping resize for invalid dimensions: ${width}x${height}`);
    }
}


/** The main animation loop, renders scene and updates controls. */
function animate() {
    requestAnimationFrame(animate); // Request the next frame

    // Update controls (needed for damping/inertia)
    if (controls) controls.update();

    // Render the scene with the camera
    if (renderer && scene && camera) renderer.render(scene, camera);
}
